
# Υποχρεωτική Εργασία ΠΣ 2

Για την εργασία αυτή έχει υλοποιηθεί ένα αρχείο **app.py**, το οποίο χρησιμοποιεί την βιβλιοθήκη **PyMongo**, καθώς και τη βιβλιοθήκη του **Flask Framework**, για τη δημιουργία μιας web εφαρμογής που χρησιμοποιεί 12 **endpoints** για να προβάλλει, να επεξεργαστεί, και να δημιουργήσει documents σε μία **MongoDB** η οποία τρέχει σε ένα περιβάλλον **Docker**.


# MongoDB Container

Για την προετοιμασία της ΒΔ δημιουργήθηκε πρώτα ένα Docker container περιέχοντας μέσα μια υλοποίηση της Mongo με την εντολή

    docker run -d -p 27017:27017 --name mongodb mongo:4.0.4

Φυσικά οι θύρα που έχουμε εισάγει είναι η 27017 καθώς εκεί θέλουμε να ακούει το πρόγραμμα.

Μετά από τα παραπάνω βήματα η βάση ήταν έτοιμη για χρήση.
  



# Προετοιμασία
Πριν ξεκινήσουμε την υλοποίηση των **endpoints** είναι απαραίτητο να γίνουν πρώτα μερικές προετοιμασίες

## Imports
1. **pymongo** - Για την επεξεργασία και τη διαχείριση της **MongoDB** βάσης δεδομένων **DSMarkets**
2. **flask** - Για τη δημιουργία του api βασισμένου στα endpoints με σκοπό της αλληλεπίδρασης μεταξύ του χρήστη και της εφαρμογής
3. **json** - Για την επεξεργασία και την εμφάνιση των JSON απαραίτητων για τη λειτουργία των MongoDb queries καθώς και την εμφάνιση αποτελεσμάτων στο χρήστη
4. **bson** - Για την ομαλή διαμόρφωση των **_id** και άλλων πεδίων που παρέχονται από τη MongoDB
5. **uuid** - Για την υλοποίηση της αυθεντικοποίησης των χρηστών
6. **time** - Όμοίως με τη βιβλιοθήκη uuid
7. **copy/deepcopy** - Αντιγραφή dict

## Initialization
Το παρακάτω δείγμα χρησιμοποιείται για την αρχικοποίηση του flask api καθώς και για τη σύνδεση της εφαρμογής στη βάση δεδομένων μας.

 

    # Connect to our local MongoDB
    
    client = MongoClient('mongodb://localhost:27017/')
    
      
    
    # Choose InfoSys database
    
    db = client['DSMarkets']
    
    users = db['Users']
    
    products = db['Products']
    
      
    
    # Initiate Flask App
    
    app = Flask(__name__)

Στη συνέχεια αρχικοποιούνται ορισμένες μεταβλητές, dictionaries και lists με σκοπό την προσωρινή αποθήκευση πληροφοριών.

    cart = {"Items": [], "Total Cost": 0}
    
    rawItems = []
    
    rawQty = []
    
    globalEmail = ""

# Endpoints

Το app.py αποτελείται από 12 διαφορετικά **endpoints**, το κάθε endpoint ολοκληρώνει συγκεκριμένες λειτουργίες, χωρισμένες σε λειτουργίες που μπορούν να πραγματοποιηθούν από έναν απλό χρήστη και σε λειτουργίες που μπορούν να πραγματοποιηθούν μόνο από διαχειριστές.

## Λειτουργίες χρήστη
 1. **/createUser** - Δημιουργία "regular" χρήστη
 2. **/login** - Είσοδος στο σύστημα
 3. **/getProduct** - Αναζήτηση προϊόντων με βάση διαφόρων τιμών (όνομα, κατηγορία, id)
 4. **/addToCart** - Προσθήκη ενός προϊόντος στο καλάθι του χρήστη με βάση το **id** του
 5. **/showCart** - Εμφάνιση του καλαθιού του χρήστη με τα αντικείμενα που έχει προσθέσει σε αυτό, μαζί με τις ποσότητες του κάθε αντικειμένου καθώς και τη συνολική τιμή του καλαθιού
 6. **/deleteFromCart** - Διαγραφή ενός αντικειμένου από το καλάθι του χρήστη με βάση το **id** του.
 7. **/purchaseCart** - Αγορά των αντικειμένων που έχει στο καλάθι του ο χρήστης, αν αυτά είναι διαθέσιμα. Απαιτεί κωδικό κάρτας.
 8. **/showOrderHistory** - Εμφάνιση όλων των πραγματοποιημένων συναλλαγών του πελάτη.
 9. **/deleteUser** - Διαγραφή του χρήστη.
 ## Λειτουργίες διαχειριστή
 10. **/insertProduct** - Προσθήκη προϊόντων στο collection Products
 11. ** /deleteProduct** - Διαγραφή προϊόντων από το κατάστημα
 12. **/modifyProduct** - Τροποποίηση πληροφοριών ενός αντικειμένου με βάση το **id** του.

## Create User

Η συνάρτηση **create_user()** λαμβάνει στο body του **POST** request ένα JSON της μορφής

```json     
{
    "email": "some email"
    "usename": "some username", 
    "password": "a very secure password"
}
```
Στη συνέχεια η εφαρμογή ελέγχει αν ο χρήστης έχει εισάγει όλα τα απαιτούμενα πεδία και συνεχίζει.

Για τον έλεγχο της ύπαρξης του **email** ήδη στην Users collection χρησιμοποίησα την εντολή

```python
users.find({"email":f"{data['email']}"}).count()
```
Έκανα αυτήν την επιλογή, καθώς κατά την αναζήτηση της ΒΔ για το username που έχουμε λάβει απο το αίτημα του χρήστη, αν έχουμε προσθέσει στο τέλος το **count()** θα λάβουμε ως αποτέλεσμα είτε το 1 (user already exists) είτε το 0 (user is not registered). Αν λοιπόν το email δε βρεθεί, κάνουμε **insert** στο Users collection τα στοιχεία του, στέλνοντας τα κατάλληλα response πίσω στο χρήστη.


## Login

Αυτό το endpoint λαμβάνει **POST** αίτημα το οποίο περιέχει **JSON** με στοιχεία το email και το password, τα οποία πρέπει να έχουν δημιουργηθεί ήδη.

Με παρόμοιο τρόπο όπως και στο προηγούμενο endpoint (χρήση του **count()**), ελέγχουμε αν τα στοιχεία υπάρχουν στη ΒΔ και αν αντιστοιχούν οι κωδικοί. Αν τα στοιχεία που έχουμε λάβει είναι σωστά, καλούμε τη συνάρτηση **create_session()** με παράμετρο το email που έχουμε ελέγξει προηγουμένως. Η συνάρτηση επιστρέφει το **uuid** το οποίο μετά εμφανίζεται στο χρήστη ώστε να το χρησιμοποιήσει στα endpoints που ακολουθούν (status 200). Επίσης, αποθηκεύουμε προσωρινά το email του χρήστη στην global μεταβλητή **globalEmail**. Αν η επαλήθευση του χρήστη αποτύχει εμφανίζεται το κατάλληλο μήνυμα αποτυχίας με status 400.

## Get Product
Το endpoint αυτό λαμβάνει αίτημα **GET** το οποίο περιέχει **JSON** με ένα από τα παρακάτω στοιχεία: 

 - name
 - category
 - id

 Ταυτόχρονα, διαβάζει το **authorization** header του αιτήματος, το οποίο χρησιμοποιείται για την επαλήθευση του session, με τη χρήση του **is_session_valid**. Αν το uuid που χρησιμοποιήθηκε στα headers δεν αντιστοιχεί στα ενεργά uuid που υπάρχουν εκείνη τη στιγμή, το endpoint τερματίζει με το μήνυμα "Not authorized", και το status 401. Αν όμως χρησιμοποιηθεί σωστό UUID, εκτελούμε την εντολή **find** στο Products collection χρησιμοποιώντας το πεδίο που έχει δοθεί απο το χρήστη και αποθηκεύουμε το αποτέλεσμα της εντολής στη μεταβλητή **productscursor**. Για να αποφύγω τα λάθη κατά την προβολή των αποτελεσμάτων της εντολής λόγω μη σειριοποιήσιμων στοιχείων των MongoDB documents, χρησιμοποίησα τη συνάρτηση **json_util.dumps()** της βιβλιοθήκης bson. Στη συνέχεια έκανα **loads** το αποτέλεσμα της συνάρτησης αυτής στο **productsearch** dictionary. Στη συνέχεια γίνεται έλεγχος αν το **productsearch** περιέχει πληροφορίες ή όχι, καθώς αν το productsearch είναι κενό, αυτό σημαίνει ότι δεν βρέθηκε κανένα προϊόν με τα στοιχεία που μας δόθηκαν. Στην περίπτωση αυτή εμφανίζεται το μήνυμα "Product(s) not found" με status 400. Αν όμως το productsearch δεν είναι κενό, εμφανίζεται στο χρήστη μαζί με status 200.

## Add To Cart

Με τον ίδιο τρόπο όπως πριν, υλοποιούμε την αυθεντικοποίηση του χρήστη, ο οποίος στέλνει αίτημα **POST**, το οποίο περιέχει JSON που περιέχει το **id** του προϊόντος που θέλει να προσθέσει στο καλάθι, καθώς και το **qty** το οποίο λέει στο πρόγραμμά μας πόσα τεμάχια θέλει να αγοράσει.
Στη συνέχεια γίνεται αναζήτηση του προϊόντος με βάση το id που μας έχει δοθεί και αποθηκεύουμε το αποτέλεσμα της αναζήτησης στο productcursor, του οποίου τα περιέχομενα γίνονται σειριοποιήσιμα με τη χρήση της βιβλιοθήκης bson, και αποθηκεύονται στη νέα μεταβλητή productsearch.

    productcursor = products.find_one({"_id": ObjectId(data['id'])})
    productsearch = json.loads(json_util.dumps(productcursor))
Αποθηκεύουμε επίσης το quantity που μας έχει δώσει ο χρήστης σε μια μεταβλητή qty για την αποφυγή σφαλμάτων.
Αν το productsearch έχει περιεχόμενα (δηλαδή αν κατά την αναζήτηση βρέθηκαν τα αντικείμενα που ζητά ο χρήστης), προσθέτουμε το τελικό κόστος (το οποίο αυξάνεται όσο ο χρήστης προσθέτει προϊόντα στο καλάθι) στο πεδίο Total Cost του cart dictionary που αρχικοποιήσαμε στην αρχή, ενώ ταυτόχρονα προσθέτουμε τα απαραίτητα items στη λίστα/πεδίο Items του cart, με μορφοποίηση ώστε να περιέχεται και ο αριθμός τεμαχίων που έχει ζητηθεί.

    cart['Total Cost'] = float(cart['Total Cost']) + float(productsearch['price']) * float(qty)
    cart['Items'].append(productsearch['name'] + " x" + qty)

Έπειτα σε δύο προσωρινές λίστες rawItems και rawQty κάνουμε append το όνομα του item και την ποσότητα αντίστοιχα. Οι δύο λίστες είναι λειτουργούν στον ίδιο index.
Τέλος, αν όλα έχουν πάει καλά εμφανίζεται το καλάθι στο χρήστη με την ακόλουθη μορφή:
```json     
{
    "Items": ["Item1 x2",
			  "Item2 x1"]
    "Total Price": "9.99", 
}
```
Αν δε βρεθεί το προϊόν τότε το endpoint τερματίζει με κωδικό 400 και το κατάλληλο μήνυμα.
## Show Cart

Αυτό το endpoint δέχεται αίτημα GET και αν έχει γίνει σωστή αυθεντικοποίηση εμφανίζεται το cart στο χρήστη με την ίδια μορφή όπως παραπάνω. Αν το καλάθι είναι άδειο τότε εμφανίζεται το κατάλληλο μήνυμα.

## Delete From Cart
Το endpoint αυτό λαμβάνει αίτημα DELETE το οποίο περιέχει στο body ένα JSON με μοναδικό πεδίο το **id** του αντικείμένου που ο χρήστης επιθυμεί να αφαιρέσει από το καλάθι.
Η αναζήτηση του προϊόντος στη βάση δεδομένων γίνεται με τον ίδιο τρόπο όπως προηγουμένως, με μονή διαφορά τη χρήση του **ObjectId** ώστε να μπορέσουμε να να αντιστοιχίσουμε το id του χρήστη με το id του MongoDB document.

    delcursor = products.find_one({"_id": ObjectId(data['id'])})
    delsearch = json.loads(json_util.dumps(delcursor))
Έπειτα αρχικοποιούνται οι μεταβλητές delFound και delIndex με τις τιμές False και 0 αντίστοιχα. Αν το id που μας έδωσε ο χρήστης αντιστοιχεί με ένα από τα αντικείμενα της βάσης δεδομένων, γίνεται αναζήτηση του ονόματος του προϊόντος στη λίστα rawItems, ώστε να βρεθεί το index που μοιράζεται μεταξύ αυτού, του rawQty, καθώς και της λίστας Items[] μέσα στο cart dictionary, με σκοπό την αφαίρεση του αντικειμένου από παντού.
Αν το προϊόν βρεθεί, τότε αφαιρούμε το item από το rawItems καθώς και το cart['Items'] με τη χρήση του pop(). Ταυτόχρονα, χρησιμοποιούμε την τιμή του αντικειμένου η οποία περιέχεται στο dictionary που αποθηκεύτηκε η αναζήτηση, πολλαπλασιάζοντας την με την ποσότητα που είχε ζητήσει ο χρήστης, για να αφαιρεθεί η τιμή από το συνολικό κόστος.

    if  delFound:
    	rawItems.pop(int(delIndex))
    	cart['Items'].pop(x)
    	cart['Total Cost'] = cart['Total Cost'] - float(delsearch['price'])*float(rawQty[x])
    	rawQty.pop(int(delIndex))
    return  Response(json.dumps(cart), status=200, mimetype='application/json')

Τέλος, εμφανίζεται το καινούργιο καλάθι στο χρήστη.
Το endpoint αυτό μπορεί να αποτύχει σε μια από αυτές τις περιπτώσεις:

 - Το προϊόν δε βρίσκεται στο καλάθι (status=400)
 - Το προϊόν δε βρίσκεται στη βάση δεδομένων (status=400)
 - Ο χρήστης δεν έχει αυθεντικοποιηθεί (status=401)

## Purchase Cart
Το endpoint αυτό λαμβάνει αίτημα **PATCH** με body περιέχοντας ένα **JSON** με μοναδικό πεδίο ένα 16-ψήφιο αριθμό κάρτας ως μέθοδο πληρωμής. Αν ο χρήστης έχει κάνει Log in γίνεται έλεγχος αν η αριθμός που έχει στείλει ο χρήστης είναι 16ψήφιος και αν δεν είναι, το endpoint τερματίζεται με τα απαραίτητα μηνύματα. Αν όμως ο κωδικός αποτελείται από 16 ψηφία, η εφαρμογή περνάει σε κάθε αντικείμενο που βρίσκεται στη λίστα rawItems αναζητώντας τα προϊόντα και ενημερώνοντας το stock του κάθε προϊόντος με τη χρήση του **products.update_one()**, όπως παρουσιάζεται από κάτω:
```python
for  y  in  range(len(rawItems)):
purchaseCursor = products.find_one({"name": f"{rawItems[y]}"})
purchaseSearch = json.loads(json_util.dumps(purchaseCursor))
newQty = int(purchaseSearch['stock']) - int(rawQty[y])
products.update_one(
{'name': rawItems[y]},
{'$set' : {'stock': newQty}}
)
```
Έπειτα αδειάζουμε όλες τις λίστες που έχουν χρησιμοποιηθεί μέχρι τώρα και προσθέτουμε το cart στο orderHistory του πελάτη.

```python
rawQty.clear()
rawItems.clear()
users.update_one(
{"email": f"{globalEmail}"},
{"$push": {"orderHistory": f"{cart}"}}
)
```
Τέλος, αντιγράφουμε το dict cart στο dict receipt με τη χρήση του deepcopy() ώστε να δημιουργήσουμε μια ασφαλή αντιγραφή τω δεδομένων, διαγράφοντας στη συνέχεια τα δεδομένα που περιέχονται μέσα στο cart για μελλοντική χρήση, και εμφανίζουμε το receipt 
```python
receipt=deepcopy(cart)

cart.clear()

return  Response(json.dumps(receipt), status=200, mimetype="application/json")
```

## Show Order History
Σε αυτό το endpoint λαμβάνεται αίτημα **GET** με authorization header και στη συνέχεια γίνεται αναζήτηση του email του χρήστη το οποίο έχει προσωρινά αποθηκευτεί στη μεταβλητή globalEmail, με παραμέτρους οι οποίες περιορίζουν τα αποτελέσματα και μας επιστρέφεται μόνο το orderHistory του χρήστη:
```python
ordercursor = users.find({"email": f"{globalEmail}"},{"_id":0,"email":0,"username":0,"password":0,"category":0})

ordersearch = json.loads(json_util.dumps(ordercursor))
```
Αν βρέθηκαν παραγγελίες, τότε αυτές εμφανίζονται στη συνέχεια. Αν όμως δε βρέθηκαν παραγγελίες το endpoint τερματίζεται με τα κατάλληλα μηνύματα.

## Delete User
Ο χρήστης στέλνει αίτημα **DELETE** και με τη χρήση του αποθηκευμένου globalEmail γίνεται η διαγραφή του από τη βάση δεδομένων (ειδικότερα το users collection), καθώς και από όλες τις προσωρινές μεταβλητές του προγράμματος.

## Insert Product
Ο διαχειριστής στέλνει αίτημα **PATCH** το οποίο στο body περιέχει όλες τις υποχρεωτικές πληροφορίες για την προσθήκη ενός προϊόντος στη βάση δεδομένων, σε μορφή JSON.  Αρχικά γίνεται αναζήτηση στη ΒΔ το globalEmail του χρήστη για να γίνει έλεγχος της κατηγορίας του χρήστη. Αν ο χρήστης δεν είναι admin το endpoint τερματίζει. Αν όμως γίνει η ταυτοποίηση, το endpoint χρησιμοποιεί τις πληροφορίες που έχουν δοθεί από το χρήστη για να προσθέσει τα καινούργια προϊόντα.

```python
products.insert_one(
{
"name":f"{data['name']}",
"category":f"{data['category']}",
"stock":f"{data['stock']}",
"description":f"{data['description']}",
"price":f"{data['price']}"
}
)
return  Response("Product succesfully added.", status=200, mimetype='application/json')
```

## Delete Product & Modify Product
Τα υπόλοιπα endpoints υλοποιούνται με όμοιο τρόπο, χρησιμοποιώντας μεθόδους **DELETE** και **PATCH** αντίστοιχα, χρησιμοποιώντας τους ίδιους τρόπους για την επίτευξη της αυθεντικοποίησης καθώς και της επεξεργασίας της ΒΔ.

Το endpoint **/deleteProduct** λαμβάνει αίτημα το οποίο περιλαμβάνει JSON με ένα μοναδικό πεδίο **id**, το οποίο αν αντιστοιχεί με κάποιο προϊόν, διαγράφεται. Αν όμως δεν υπάρχει το αντικείμενο αυτό, το endpoint τερματίζει ενημερώνοντας το χρήστη.

Το endpoint **/modifyProduct** λαμβάνει αίτημα το οποίο περιλαμβάνει JSON το οποίο πρέπει να περιέχει το **id** του προϊόντος που επιθυμούμε να επεξεργαστούμε, μαζί με ένα εως και όλα από τα ακόλουθα πεδία:

 - name
 - price
 - description
 - category
 - stock

Το πρόγραμμα διαβάζει ποια πεδία έχουν δοθεί από το χρήστη και κάνει τις απαραίτητες αλλαγές ανάλογα με την περίπτωση

```python
if  "name"  in  data:
  
products.update_one(
{
"_id":ObjectId(data['id'])
},
{
{"$set":{"name": f"{data['name']}"}}
})
if  "price"  in  data:
products.update_one(
{
"_id": ObjectId(data['id'])
},
{
{"$set": {"price": f"{data['price']}"}}
})
if  "description"  in  data:
products.update_one(
{
"_id": ObjectId(data['id'])
},
{
{"$set": {"description": f"{data['description']}"}}
})
if  "stock"  in  data:
products.update_one(
{
"_id": ObjectId(data['id'])
},
{
{"$set": {"name": f"{data['stock']}"}}
})
return  Response("Product succesfully modified.", status=200, mimetype='application/json')
```

# Σημειωση
**Σε κάθε endpoint έχει υλοποιηθεί ο έλεγχος του UUID. Αν ο χρήστης δεν είναι αυθεντικοποιημένος, ολα τα endpoint τερματίζουν με το μήνυμα "Not authorized" και το status 401.**
